## transaction (트랜잭션)

- 데이터를 저장하는데 데이터베이스에 굳이 따로 저장하는 이유는 무엇일까?<br>
여러가지 이유가 있지만 데이터베이스에서는 transaction (트랜잭션) 개념을 지원 해주기 때문이다.<br><br>

데이터베이스에서 트랜잭션은 하나의 거래를 안전하게 처리하는것을 보장해준다. 예를들어, <br>

*5000원의 계좌이체*
- 1. A의 잔고 5000원 감소
  2. B의 잔고 5000원 증가

<br><br> 계좌이체라는 거래는 이 두가지 작업이 합쳐져서 하나의 작업처럼 동작해야한다. 
<br> 그런데 1번은 수행 됐는데 2번을 작업도중 에러가 발생하면 어떻게 될까?
<br> 계좌이체는 실패하고, A의 잔고만 5000원 감소하는 심각한 문제가 발생하게 될 것이다.
<br> 데이터베이스의 트랜잭션을 사용하면 1,2 둘다 성공해야 저장하고 중간에 하나라도 실패하면 거래 전의 상태로 돌아갈 수 있다.
<br>
<br> 모든 작업이 성공해서 데이터베이스에 정상반영 하는것을 `commit` 이라고 하고, 작업 중 하나라도 실패해 되 돌아가는 것을 `롤백`  (RollBack) 이라고 한다.

### 트랜잭션 ACID
트랜잭션은 ACID 라 하는 원자성(Atomicity),일관성(Consistency),격리성(Isolation),지속성(Durability)을 보장해야한다.
- *원자성* : 트랜잭션 내에서 실행한 작업들은 하나의 작업인것 처럼 모두 성공하거나 모두 실패해야만한다.
- *일관성* : 모든 트랙잭션은 일관성있는 상태를 유지해야한 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야한다. 
- *격리성* : 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지않도록 격리해야한다, 독립적으로 수행되어야한다.
- *지속성* : 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야한다. 중간에 문제가 발생해도 데이터베이스 로그 등을 이용해서 성공한 트랜잭션 내용을 복구해야한다. 

<br> 문제는 격리성을 완벽하게 보장할려면 트랜잭션을 거의 순서대로 실행해야한다. 하지만 이렇게 하면 동시처리 성능이 매우 나빠진다.
<br> 이런 문제로 인해 트랜잭션 격리 수준을 4단계로 나누어 정의했다

<br> *트랜잭션 격리 수준*
- READ UNCOMMITED(커밋되지않은 읽기) 
- READ COMMITED(커밋된 읽기)
- REPEATABLE READ(반복가능한 읽기)
- SERIALIZABLE(직렬화기능) 

