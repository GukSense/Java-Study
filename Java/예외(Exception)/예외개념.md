##  오류
- 프로그램을 실행하다가 보면 어떤 원인때문에 **비정상적인 동작을 일으키며 프로그램이 종료되는 상황**이 있다. 이때 우리는 프로그램이 오류가 발생했다라고 표현한다.
- 프로그래밍적인 관점에서 오류를 계층구조로 나타내면 다음과같이 표현 할 수 있다.
<br> **오류계층구조**
![image](https://github.com/GukSense/TIL/assets/101082667/5f931087-1f46-4888-9d9e-a569f9217dea)

- **컴파일 오류**
  - *오타*,*변수타입 불일치*,*변수미정의* 등이 대표적인 예로 볼 수 있다.
- **런타임 오류**
  - 프로그램이 실행중에 발생되는 오류다 주로  `Throwable` 클래스로 불리며 모든 예외 클래스의 최상위 클래스다. 하위 클래스로 `Exception` `Error ` 클래스가 있다.
- **Error클래스**
  - 프로그래머가 직접 처리하기 어려운, 시스템 수준의 심각한 오류. Ex) `OutOfMemoryError` , `StackOverflowError` 애플리케이션에서 복구 불가능한 시스탬 예외.
  - 개발자는 이 예외를 잡으려고 해서는 안된다.
- **Exception 클래스**
  - 프로그래머가 직접 예측하여 막을 수 있는 처리가능한 오류.
  - 애플리케이션 로직에서 사용할 수 있는 실질적인  최상위 예외클래스이다. 
  - `Exception` 과 그 하위 클래스는 `RuntimeException` 클래스를 제외하고 컴파일러가 체크하는 **체크예외**이다.
- **RuntimeException**
  -  언체크예외, 런타임 예외.
  -  `RuntimeException` 과 그 하위클래스는 모두 **언체크 예외**이다. 주로 **런타임예외** 라고 많이 부른다.


### 에외 기본 규칙
- 예외는 잡아서 처리하거나 던져야한다.
- 예외를 잡거나 던질때 지정한 예외 뿐만 아니라 그 하위클래스의 예외까지 함께 처리된다.

### 체크 예외와 언체크예외 (런타임예외)
<br> **체크예외**
  - 체크예외는 반드시 명시적으로 잡아서 처리하거나 던져야한다. 그렇지않을경우 컴파일 오류가 발생.
    - 장점: 개발자가 실수로 예외를 누락하지 않도록 컴파일러를 통해 문제를 잡아주는 훌륭한 안전장치
    - 단점: 개발자가 모든 예외를 잡아서처리하거나, 던져야하기 때문에 너무 번거로운 작업이되고 크게 신경쓰고싶지않은 예외까지 모두 처리해야한다. 또 의존성 문제까지 발생 할 수 있다.
   
<br> **언체크예외**
  - 언체크예외는 컴파일러가 예외를 체크하지않는다. `throws` 를 생략할 수 있고 생략 시 자동으로 예외를 던진다.
    - 장점: 신경쓰고싶지않은 언체크 예외를 무시할 수 있다. 신경쓰고 싶지 않은 예외의 의존관계를 참조하지 않아도 된다.  
    - 단점: 실수로 예외를 개발자가 누락할 수 있다.
#### 정리
체크예외와 언체크예외의 차이는 예외를 처리 할 수 없을때, 해당 예외를 throws를 필수로 선언해야하는가 , 그냥 생략 할 수 있는가 의 차이가 제일 크다.



